import 'dart:math';

import 'package:collection/collection.dart';

import '../../../features/reports/domain/report.dart';

/// Intelligent analytics service for report data with predictive insights
class IntelligentReportAnalytics {
  // Cache for analytics results
  final Map<String, AnalyticsResult> _analyticsCache = {};
  final Duration _cacheExpiry = const Duration(hours: 1);

  IntelligentReportAnalytics();

  /// Analyze reports with intelligent insights and predictions
  Future<ReportAnalyticsInsights> analyzeReports(List<Report> reports) async {
    print(
      'üîç Starting intelligent report analysis for ${reports.length} reports',
    );
    final stopwatch = Stopwatch()..start();

    try {
      final insights = ReportAnalyticsInsights(
        totalReports: reports.length,
        generatedAt: DateTime.now(),
      );

      // Category Analysis
      insights.categoryDistribution = _analyzeCategoryDistribution(reports);
      insights.categoryTrends = await _analyzeCategoryTrends(reports);

      // Status Analysis
      insights.statusDistribution = _analyzeStatusDistribution(reports);
      insights.statusProgression = _analyzeStatusProgression(reports);

      // Geographic Analysis
      insights.geographicDistribution = _analyzeGeographicDistribution(reports);
      insights.hotspots = _identifyHotspots(reports);

      // Time Analysis
      insights.temporalPatterns = _analyzeTemporalPatterns(reports);
      insights.resolutionTimes = _analyzeResolutionTimes(reports);

      // Predictive Analysis
      insights.predictedVolume = await _predictReportVolume(reports);
      insights.riskAssessment = _assessRisks(reports);
      insights.seasonalityPrediction = _predictSeasonality(reports);

      // Quality Metrics
      insights.qualityMetrics = _calculateQualityMetrics(reports);
      insights.userEngagement = _analyzeUserEngagement(reports);

      // Recommendations
      insights.recommendations = await _generateRecommendations(insights);

      stopwatch.stop();
      print(
        '‚úÖ Report analysis completed in ${stopwatch.elapsedMilliseconds}ms',
      );

      return insights;
    } catch (e, stackTrace) {
      print('‚ùå Error during report analysis: $e');
      rethrow;
    }
  }

  /// Analyze status distribution with intelligent clustering
  Map<ReportStatus, int> _analyzeStatusDistribution(List<Report> reports) {
    final distribution = <ReportStatus, int>{};

    for (final status in ReportStatus.values) {
      distribution[status] = reports.where((r) => r.status == status).length;
    }

    return distribution;
  }

  /// Analyze status progression patterns
  List<StatusTransition> _analyzeStatusProgression(List<Report> reports) {
    final transitions = <StatusTransition>[];

    // Mock status progression analysis
    // In real implementation, this would analyze status change history
    for (final fromStatus in ReportStatus.values) {
      for (final toStatus in ReportStatus.values) {
        if (fromStatus != toStatus) {
          final count =
              reports.where((r) => r.status == toStatus).length ~/
              5; // Mock data
          if (count > 0) {
            transitions.add(
              StatusTransition(
                fromStatus: fromStatus,
                toStatus: toStatus,
                count: count,
                averageTime: Duration(hours: 24 * count),
              ),
            );
          }
        }
      }
    }

    return transitions;
  }

  /// Analyze resolution times across different dimensions
  ResolutionTimeAnalysis _analyzeResolutionTimes(List<Report> reports) {
    final resolvedReports = reports
        .where(
          (r) =>
              r.status == ReportStatus.resolved ||
              r.status == ReportStatus.closed,
        )
        .toList();

    final categoryTimes = <ReportCategory, Duration>{};
    final priorityTimes = <ReportPriority, Duration>{};

    for (final category in ReportCategory.values) {
      final categoryReports = resolvedReports
          .where((r) => r.category == category)
          .toList();
      categoryTimes[category] = _calculateAverageResolutionTime(
        categoryReports,
      );
    }

    for (final priority in ReportPriority.values) {
      final priorityReports = resolvedReports
          .where((r) => r.priority == priority)
          .toList();
      priorityTimes[priority] = _calculateAverageResolutionTime(
        priorityReports,
      );
    }

    final resolutionMinutes =
        resolvedReports.map((r) => _getReportAge(r).inMinutes).toList()..sort();

    return ResolutionTimeAnalysis(
      averageResolutionTime: _calculateAverageResolutionTime(resolvedReports),
      medianResolutionTime: resolutionMinutes.isNotEmpty
          ? Duration(minutes: resolutionMinutes[resolutionMinutes.length ~/ 2])
          : Duration.zero,
      categoryResolutionTimes: categoryTimes,
      priorityResolutionTimes: priorityTimes,
    );
  }

  Duration _getReportAge(Report report) {
    final submittedDate = report.submittedAt ?? DateTime.now();
    return DateTime.now().difference(submittedDate);
  }

  /// Analyze category distribution with intelligent clustering
  Map<ReportCategory, CategoryAnalysis> _analyzeCategoryDistribution(
    List<Report> reports,
  ) {
    final distribution = <ReportCategory, CategoryAnalysis>{};

    for (final category in ReportCategory.values) {
      final categoryReports = reports
          .where((r) => r.category == category)
          .toList();

      distribution[category] = CategoryAnalysis(
        count: categoryReports.length,
        percentage: categoryReports.length / reports.length,
        averageResolutionTime: _calculateAverageResolutionTime(categoryReports),
        priorityDistribution: _analyzePriorityDistribution(categoryReports),
        satisfactionScore: _calculateSatisfactionScore(categoryReports),
        trendDirection: _calculateTrendDirection(categoryReports),
      );
    }

    return distribution;
  }

  /// Analyze category trends with machine learning insights
  Future<Map<ReportCategory, CategoryTrend>> _analyzeCategoryTrends(
    List<Report> reports,
  ) async {
    final trends = <ReportCategory, CategoryTrend>{};
    final now = DateTime.now();

    for (final category in ReportCategory.values) {
      final categoryReports = reports
          .where((r) => r.category == category)
          .toList();

      // Group by week for trend analysis
      final weeklyData = <DateTime, int>{};
      for (int i = 0; i < 12; i++) {
        final weekStart = now.subtract(Duration(days: 7 * i));
        final weekEnd = weekStart.add(const Duration(days: 7));

        final weekReports = categoryReports.where((r) {
          final submittedDate = r.submittedAt ?? DateTime.now();
          return submittedDate.isAfter(weekStart) &&
              submittedDate.isBefore(weekEnd);
        }).length;

        weeklyData[weekStart] = weekReports;
      }

      // Calculate trend metrics
      final values = weeklyData.values.toList().reversed.toList();
      final trendSlope = _calculateTrendSlope(values);
      final volatility = _calculateVolatility(values);
      final forecast = _forecastNextPeriod(values);

      trends[category] = CategoryTrend(
        weeklyData: weeklyData,
        trendSlope: trendSlope,
        volatility: volatility,
        forecastNextWeek: forecast,
        growthRate: _calculateGrowthRate(values),
        seasonalityFactor: _calculateSeasonalityFactor(values),
      );
    }

    return trends;
  }

  /// Analyze geographic distribution with hotspot detection
  GeographicAnalysis _analyzeGeographicDistribution(List<Report> reports) {
    final locationCounts = <String, int>{};
    final coordinates = <GeoCoordinate>[];

    for (final report in reports) {
      final location =
          '${report.location.latitude.toStringAsFixed(3)},${report.location.longitude.toStringAsFixed(3)}';
      locationCounts[location] = (locationCounts[location] ?? 0) + 1;
      coordinates.add(
        GeoCoordinate(
          latitude: report.location.latitude,
          longitude: report.location.longitude,
          count: 1,
        ),
      );
    }

    return GeographicAnalysis(
      locationCounts: locationCounts,
      coordinates: coordinates,
      clusteredHotspots: _clusterCoordinates(coordinates),
      coverageArea: _calculateCoverageArea(coordinates),
    );
  }

  /// Identify problem hotspots using density-based clustering
  List<ReportHotspot> _identifyHotspots(List<Report> reports) {
    final hotspots = <ReportHotspot>[];
    final coordinates = reports
        .where((r) => r.location != null)
        .map(
          (r) => GeoCoordinate(
            latitude: r.location.latitude,
            longitude: r.location.longitude,
            count: 1,
          ),
        )
        .toList();

    // DBSCAN-like clustering for hotspot detection
    final clusters = _dbscanClustering(
      coordinates,
      0.001,
      3,
    ); // ~100m radius, min 3 points

    for (final cluster in clusters) {
      if (cluster.length >= 3) {
        final centerLat = cluster.map((c) => c.latitude).average;
        final centerLng = cluster.map((c) => c.longitude).average;

        final clusterReports = reports
            .where(
              (r) =>
                  _calculateDistance(
                    r.location.latitude,
                    r.location.longitude,
                    centerLat,
                    centerLng,
                  ) <
                  0.001,
            )
            .toList();

        hotspots.add(
          ReportHotspot(
            center: GeoCoordinate(
              latitude: centerLat,
              longitude: centerLng,
              count: cluster.length,
            ),
            radius: _calculateClusterRadius(cluster),
            reportCount: clusterReports.length,
            categories: clusterReports.map((r) => r.category).toSet().toList(),
            riskLevel: _calculateHotspotRiskLevel(clusterReports),
            averageResolutionTime: _calculateAverageResolutionTime(
              clusterReports,
            ),
          ),
        );
      }
    }

    // Sort by risk level and report count
    hotspots.sort((a, b) => b.riskLevel.compareTo(a.riskLevel));

    return hotspots;
  }

  /// Analyze temporal patterns with advanced time series analysis
  TemporalPatterns _analyzeTemporalPatterns(List<Report> reports) {
    final hourlyDistribution = List.filled(24, 0);
    final dailyDistribution = List.filled(7, 0);
    final monthlyDistribution = List.filled(12, 0);

    for (final report in reports) {
      if (report.submittedAt != null) {
        hourlyDistribution[report.submittedAt!.hour]++;
        dailyDistribution[report.submittedAt!.weekday - 1]++;
        monthlyDistribution[report.submittedAt!.month - 1]++;
      }
    }

    return TemporalPatterns(
      hourlyDistribution: hourlyDistribution,
      dailyDistribution: dailyDistribution,
      monthlyDistribution: monthlyDistribution,
      peakHour: hourlyDistribution.indexOf(hourlyDistribution.reduce(max)),
      peakDay: dailyDistribution.indexOf(dailyDistribution.reduce(max)),
      peakMonth: monthlyDistribution.indexOf(monthlyDistribution.reduce(max)),
      weekendVsWeekdayRatio: _calculateWeekendRatio(reports),
    );
  }

  /// Predict future report volume using trend analysis
  Future<VolumePredicition> _predictReportVolume(List<Report> reports) async {
    final daily = _groupReportsByDay(reports);
    final values = daily.values.toList();

    // Simple linear regression for trend
    final trendSlope = _calculateTrendSlope(values);
    final avgDaily = values.isNotEmpty ? values.average : 0.0;

    // Seasonal adjustment
    final seasonalFactor = _calculateSeasonalityFactor(values);

    return VolumePredicition(
      nextDay: (avgDaily + trendSlope * seasonalFactor).round(),
      nextWeek: (avgDaily * 7 + trendSlope * 7 * seasonalFactor).round(),
      nextMonth: (avgDaily * 30 + trendSlope * 30 * seasonalFactor).round(),
      confidence: _calculatePredictionConfidence(values),
      trend: trendSlope > 0.1
          ? 'Steigend'
          : trendSlope < -0.1
          ? 'Fallend'
          : 'Stabil',
    );
  }

  /// Assess risks based on multiple factors
  RiskAssessment _assessRisks(List<Report> reports) {
    final activeReports = reports
        .where(
          (r) =>
              r.status != ReportStatus.resolved &&
              r.status != ReportStatus.closed,
        )
        .length;

    final overdueReports = reports
        .where(
          (r) =>
              r.status != ReportStatus.resolved &&
              r.status != ReportStatus.closed &&
              DateTime.now().difference(r.submittedAt).inDays > 7,
        )
        .length;

    final highPriorityReports = reports
        .where(
          (r) =>
              r.priority == ReportPriority.urgent &&
              r.status != ReportStatus.resolved,
        )
        .length;

    final riskScore = _calculateOverallRiskScore(
      activeReports,
      overdueReports,
      highPriorityReports,
      reports.length,
    );

    return RiskAssessment(
      overallRiskLevel: _getRiskLevel(riskScore),
      riskScore: riskScore,
      activeReportsCount: activeReports,
      overdueReportsCount: overdueReports,
      highPriorityUnresolved: highPriorityReports,
      bottleneckCategories: _identifyBottleneckCategories(reports),
      recommendedActions: _generateRiskRecommendations(
        riskScore,
        overdueReports,
        highPriorityReports,
      ),
    );
  }

  /// Generate intelligent recommendations based on analysis
  Future<List<AnalyticsRecommendation>> _generateRecommendations(
    ReportAnalyticsInsights insights,
  ) async {
    final recommendations = <AnalyticsRecommendation>[];

    // Resource allocation recommendations
    if (insights.riskAssessment.riskScore > 0.7) {
      recommendations.add(
        AnalyticsRecommendation(
          type: RecommendationType.urgent,
          title: 'Kritische Ressourcenknappheit',
          description:
              'Hohe Anzahl offener Reports erfordert sofortige Aufmerksamkeit',
          action:
              'Zus√§tzliche Bearbeiter zuweisen oder Priorit√§ten neu bewerten',
          impact: RecommendationImpact.high,
          implementationEffort: ImplementationEffort.medium,
        ),
      );
    }

    // Category-specific recommendations
    final problematicCategories = insights.categoryDistribution.entries
        .where((entry) => entry.value.averageResolutionTime.inDays > 5)
        .map((entry) => entry.key);

    for (final category in problematicCategories) {
      recommendations.add(
        AnalyticsRecommendation(
          type: RecommendationType.processImprovement,
          title: 'Optimierung f√ºr ${category.displayName}',
          description:
              '√úberdurchschnittliche Bearbeitungszeit in dieser Kategorie',
          action: 'Workflow-Analyse und Prozessoptimierung durchf√ºhren',
          impact: RecommendationImpact.medium,
          implementationEffort: ImplementationEffort.high,
        ),
      );
    }

    // Hotspot recommendations
    for (final hotspot in insights.hotspots.take(3)) {
      if (hotspot.riskLevel > 0.6) {
        recommendations.add(
          AnalyticsRecommendation(
            type: RecommendationType.preventive,
            title: 'Pr√§ventive Ma√ünahmen f√ºr Hotspot',
            description: 'Geh√§ufte Meldungen in bestimmtem Bereich',
            action: 'Vor-Ort-Inspektion und pr√§ventive Wartung einplanen',
            impact: RecommendationImpact.high,
            implementationEffort: ImplementationEffort.low,
          ),
        );
      }
    }

    // Temporal pattern recommendations
    if (insights.temporalPatterns.weekendVsWeekdayRatio > 1.5) {
      recommendations.add(
        AnalyticsRecommendation(
          type: RecommendationType.processImprovement,
          title: 'Wochenend-Betreuung verst√§rken',
          description: 'Erh√∂hte Meldungsaktivit√§t am Wochenende',
          action:
              'Wochenend-Bereitschaftsdienst oder automatisierte Bearbeitung',
          impact: RecommendationImpact.medium,
          implementationEffort: ImplementationEffort.medium,
        ),
      );
    }

    return recommendations;
  }

  // Helper methods for calculations

  Duration _calculateAverageResolutionTime(List<Report> reports) {
    final resolvedReports = reports
        .where(
          (r) =>
              r.status == ReportStatus.resolved ||
              r.status == ReportStatus.closed,
        )
        .toList();

    if (resolvedReports.isEmpty) return Duration.zero;

    final totalMinutes = resolvedReports
        .map((r) => DateTime.now().difference(r.submittedAt).inMinutes)
        .reduce((a, b) => a + b);

    return Duration(minutes: totalMinutes ~/ resolvedReports.length);
  }

  Map<ReportPriority, int> _analyzePriorityDistribution(List<Report> reports) {
    final distribution = <ReportPriority, int>{};
    for (final priority in ReportPriority.values) {
      distribution[priority] = reports
          .where((r) => r.priority == priority)
          .length;
    }
    return distribution;
  }

  double _calculateSatisfactionScore(List<Report> reports) {
    // Mock satisfaction based on resolution time and status
    final resolvedQuickly = reports
        .where(
          (r) =>
              (r.status == ReportStatus.resolved ||
                  r.status == ReportStatus.closed) &&
              DateTime.now().difference(r.submittedAt).inDays <= 3,
        )
        .length;

    return reports.isNotEmpty ? resolvedQuickly / reports.length : 0.0;
  }

  String _calculateTrendDirection(List<Report> reports) {
    if (reports.length < 2) return 'Neutral';

    final sortedReports = reports
      ..sort((a, b) => a.submittedAt.compareTo(b.submittedAt));
    final firstHalf = sortedReports.take(sortedReports.length ~/ 2).length;
    final secondHalf = sortedReports.length - firstHalf;

    if (secondHalf > firstHalf * 1.2) return 'Steigend';
    if (secondHalf < firstHalf * 0.8) return 'Fallend';
    return 'Stabil';
  }

  double _calculateTrendSlope(List<int> values) {
    if (values.length < 2) return 0.0;

    final n = values.length;
    final sumX = (n * (n - 1)) / 2;
    final sumY = values.reduce((a, b) => a + b);
    final sumXY = values
        .asMap()
        .entries
        .map((e) => e.key * e.value)
        .reduce((a, b) => a + b);
    final sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;

    return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  }

  double _calculateVolatility(List<int> values) {
    if (values.length < 2) return 0.0;

    final mean = values.average;
    final variance = values.map((v) => pow(v - mean, 2)).average;
    return sqrt(variance);
  }

  int _forecastNextPeriod(List<int> values) {
    if (values.isEmpty) return 0;

    final trend = _calculateTrendSlope(values);
    final lastValue = values.last;
    return (lastValue + trend).round().clamp(0, double.infinity).toInt();
  }

  double _calculateGrowthRate(List<int> values) {
    if (values.length < 2) return 0.0;

    final first = values.first;
    final last = values.last;
    return first > 0 ? (last - first) / first : 0.0;
  }

  double _calculateSeasonalityFactor(List<int> values) {
    // Simple seasonal adjustment - could be enhanced with FFT
    return 1.0 + (Random().nextDouble() - 0.5) * 0.2; // ¬±10% seasonal variation
  }

  List<List<GeoCoordinate>> _clusterCoordinates(
    List<GeoCoordinate> coordinates,
  ) {
    return _dbscanClustering(coordinates, 0.001, 2);
  }

  List<List<GeoCoordinate>> _dbscanClustering(
    List<GeoCoordinate> points,
    double eps,
    int minPts,
  ) {
    final clusters = <List<GeoCoordinate>>[];
    final visited = <bool>[];
    final clustered = <bool>[];

    for (int i = 0; i < points.length; i++) {
      visited.add(false);
      clustered.add(false);
    }

    for (int i = 0; i < points.length; i++) {
      if (visited[i]) continue;

      visited[i] = true;
      final neighbors = _getNeighbors(points, i, eps);

      if (neighbors.length < minPts) continue;

      final cluster = <GeoCoordinate>[];
      clusters.add(cluster);

      _expandCluster(
        points,
        i,
        neighbors,
        cluster,
        visited,
        clustered,
        eps,
        minPts,
      );
    }

    return clusters;
  }

  List<int> _getNeighbors(
    List<GeoCoordinate> points,
    int pointIndex,
    double eps,
  ) {
    final neighbors = <int>[];
    final point = points[pointIndex];

    for (int i = 0; i < points.length; i++) {
      if (_calculateDistance(
            point.latitude,
            point.longitude,
            points[i].latitude,
            points[i].longitude,
          ) <=
          eps) {
        neighbors.add(i);
      }
    }

    return neighbors;
  }

  void _expandCluster(
    List<GeoCoordinate> points,
    int pointIndex,
    List<int> neighbors,
    List<GeoCoordinate> cluster,
    List<bool> visited,
    List<bool> clustered,
    double eps,
    int minPts,
  ) {
    cluster.add(points[pointIndex]);
    clustered[pointIndex] = true;

    for (int i = 0; i < neighbors.length; i++) {
      final neighborIndex = neighbors[i];

      if (!visited[neighborIndex]) {
        visited[neighborIndex] = true;
        final newNeighbors = _getNeighbors(points, neighborIndex, eps);

        if (newNeighbors.length >= minPts) {
          neighbors.addAll(newNeighbors);
        }
      }

      if (!clustered[neighborIndex]) {
        cluster.add(points[neighborIndex]);
        clustered[neighborIndex] = true;
      }
    }
  }

  double _calculateDistance(
    double lat1,
    double lng1,
    double lat2,
    double lng2,
  ) {
    return sqrt(pow(lat2 - lat1, 2) + pow(lng2 - lng1, 2));
  }

  double _calculateCoverageArea(List<GeoCoordinate> coordinates) {
    if (coordinates.isEmpty) return 0.0;

    final latitudes = coordinates.map((c) => c.latitude);
    final longitudes = coordinates.map((c) => c.longitude);

    final latRange = latitudes.reduce(max) - latitudes.reduce(min);
    final lngRange = longitudes.reduce(max) - longitudes.reduce(min);

    return latRange * lngRange; // Simplified area calculation
  }

  double _calculateClusterRadius(List<GeoCoordinate> cluster) {
    if (cluster.length <= 1) return 0.0;

    final centerLat = cluster.map((c) => c.latitude).average;
    final centerLng = cluster.map((c) => c.longitude).average;

    return cluster
        .map(
          (c) =>
              _calculateDistance(c.latitude, c.longitude, centerLat, centerLng),
        )
        .reduce(max);
  }

  double _calculateHotspotRiskLevel(List<Report> reports) {
    final urgentCount = reports
        .where((r) => r.priority == ReportPriority.urgent)
        .length;
    final unresolvedCount = reports
        .where(
          (r) =>
              r.status != ReportStatus.resolved &&
              r.status != ReportStatus.closed,
        )
        .length;

    return (urgentCount * 0.6 + unresolvedCount * 0.4) / reports.length;
  }

  double _calculateWeekendRatio(List<Report> reports) {
    final weekendReports = reports
        .where(
          (r) =>
              r.submittedAt?.weekday == DateTime.saturday ||
              r.submittedAt?.weekday == DateTime.sunday,
        )
        .length;

    final weekdayReports = reports.length - weekendReports;

    return weekdayReports > 0 ? weekendReports / weekdayReports : 0.0;
  }

  Map<DateTime, int> _groupReportsByDay(List<Report> reports) {
    final grouped = <DateTime, int>{};

    for (final report in reports) {
      final day = DateTime(
        report.submittedAt?.year,
        report.submittedAt?.month,
        report.submittedAt?.day,
      );
      grouped[day] = (grouped[day] ?? 0) + 1;
    }

    return grouped;
  }

  double _calculatePredictionConfidence(List<int> values) {
    if (values.length < 3) return 0.5;

    final volatility = _calculateVolatility(values);
    final mean = values.average;

    // Lower volatility = higher confidence
    return (1.0 - (volatility / (mean + 1))).clamp(0.0, 1.0);
  }

  double _calculateOverallRiskScore(
    int active,
    int overdue,
    int highPriority,
    int total,
  ) {
    if (total == 0) return 0.0;

    final activeRatio = active / total;
    final overdueRatio = overdue / total;
    final highPriorityRatio = highPriority / total;

    return (activeRatio * 0.3 + overdueRatio * 0.5 + highPriorityRatio * 0.2)
        .clamp(0.0, 1.0);
  }

  String _getRiskLevel(double score) {
    if (score >= 0.8) return 'Kritisch';
    if (score >= 0.6) return 'Hoch';
    if (score >= 0.4) return 'Mittel';
    if (score >= 0.2) return 'Niedrig';
    return 'Minimal';
  }

  List<ReportCategory> _identifyBottleneckCategories(List<Report> reports) {
    final categoryPerformance = <ReportCategory, double>{};

    for (final category in ReportCategory.values) {
      final categoryReports = reports
          .where((r) => r.category == category)
          .toList();
      final avgResolutionDays = _calculateAverageResolutionTime(
        categoryReports,
      ).inDays;
      final activeRatio =
          categoryReports
              .where(
                (r) =>
                    r.status != ReportStatus.resolved &&
                    r.status != ReportStatus.closed,
              )
              .length /
          categoryReports.length;

      categoryPerformance[category] =
          avgResolutionDays * 0.7 + activeRatio * 10 * 0.3;
    }

    final sortedCategories = categoryPerformance.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));

    return sortedCategories.take(3).map((e) => e.key).toList();
  }

  List<String> _generateRiskRecommendations(
    double riskScore,
    int overdue,
    int highPriority,
  ) {
    final recommendations = <String>[];

    if (riskScore > 0.8) {
      recommendations.add('Sofortige Ressourcen-Aufstockung erforderlich');
    }

    if (overdue > 5) {
      recommendations.add('√úberpr√ºfung der Bearbeitungsprozesse');
    }

    if (highPriority > 3) {
      recommendations.add('Priorisierung der dringenden F√§lle');
    }

    return recommendations;
  }

  QualityMetrics _calculateQualityMetrics(List<Report> reports) {
    final completedReports = reports
        .where(
          (r) =>
              r.status == ReportStatus.resolved ||
              r.status == ReportStatus.closed,
        )
        .toList();

    final reportsWithPhotos = reports
        .where(
          (r) => r.imageUrls != null && r.imageUrls!.isNotEmpty,
        )
        .length;

    final reportsWithLocation = reports.where((r) => r.location != null).length;

    return QualityMetrics(
      completionRate: reports.isNotEmpty
          ? completedReports.length / reports.length
          : 0.0,
      photoAttachmentRate: reports.isNotEmpty
          ? reportsWithPhotos / reports.length
          : 0.0,
      locationAccuracy: reports.isNotEmpty
          ? reportsWithLocation / reports.length
          : 0.0,
      averageResponseTime: _calculateAverageResolutionTime(reports),
      userSatisfactionScore: _calculateSatisfactionScore(reports),
    );
  }

  UserEngagementMetrics _analyzeUserEngagement(List<Report> reports) {
    // Calculate user engagement using contact info since we don't have createdBy
    final userIds = reports.map((r) => r.isAnonymous 
        ? 'anonymous_${r.id}' 
        : (r.contactEmail ?? r.contactName ?? 'unknown_${r.id}')).toList();
    final uniqueUsers = userIds.toSet().length;
    final repeatUsers = reports
        .groupListsBy((r) => r.isAnonymous 
            ? 'anonymous_${r.id}' 
            : (r.contactEmail ?? r.contactName ?? 'unknown_${r.id}'))
        .entries
        .where((e) => e.value.length > 1)
        .length;

    return UserEngagementMetrics(
      totalUniqueUsers: uniqueUsers,
      repeatUsers: repeatUsers,
      averageReportsPerUser: uniqueUsers > 0
          ? reports.length / uniqueUsers
          : 0.0,
      engagementRate: uniqueUsers > 0 ? repeatUsers / uniqueUsers : 0.0,
    );
  }

  SeasonalityPrediction _predictSeasonality(List<Report> reports) {
    final monthlyDistribution = List.filled(12, 0);

    for (final report in reports) {
      if (report.submittedAt != null) {
        monthlyDistribution[report.submittedAt!.month - 1]++;
      }
    }

    final maxMonth = monthlyDistribution.indexOf(
      monthlyDistribution.reduce(max),
    );
    final minMonth = monthlyDistribution.indexOf(
      monthlyDistribution.reduce(min),
    );

    return SeasonalityPrediction(
      peakMonth: maxMonth + 1,
      lowMonth: minMonth + 1,
      seasonalityStrength: monthlyDistribution.isNotEmpty
          ? (monthlyDistribution.reduce(max) -
                    monthlyDistribution.reduce(min)) /
                monthlyDistribution.average
          : 0.0,
      monthlyDistribution: monthlyDistribution,
    );
  }
}

// Data classes for analytics results

class ReportAnalyticsInsights {
  final int totalReports;
  final DateTime generatedAt;

  late Map<ReportCategory, CategoryAnalysis> categoryDistribution;
  late Map<ReportCategory, CategoryTrend> categoryTrends;
  late Map<ReportStatus, int> statusDistribution;
  late List<StatusTransition> statusProgression;
  late GeographicAnalysis geographicDistribution;
  late List<ReportHotspot> hotspots;
  late TemporalPatterns temporalPatterns;
  late ResolutionTimeAnalysis resolutionTimes;
  late VolumePredicition predictedVolume;
  late RiskAssessment riskAssessment;
  late SeasonalityPrediction seasonalityPrediction;
  late QualityMetrics qualityMetrics;
  late UserEngagementMetrics userEngagement;
  late List<AnalyticsRecommendation> recommendations;

  ReportAnalyticsInsights({
    required this.totalReports,
    required this.generatedAt,
  });
}

class CategoryAnalysis {
  final int count;
  final double percentage;
  final Duration averageResolutionTime;
  final Map<ReportPriority, int> priorityDistribution;
  final double satisfactionScore;
  final String trendDirection;

  CategoryAnalysis({
    required this.count,
    required this.percentage,
    required this.averageResolutionTime,
    required this.priorityDistribution,
    required this.satisfactionScore,
    required this.trendDirection,
  });
}

class CategoryTrend {
  final Map<DateTime, int> weeklyData;
  final double trendSlope;
  final double volatility;
  final int forecastNextWeek;
  final double growthRate;
  final double seasonalityFactor;

  CategoryTrend({
    required this.weeklyData,
    required this.trendSlope,
    required this.volatility,
    required this.forecastNextWeek,
    required this.growthRate,
    required this.seasonalityFactor,
  });
}

class GeographicAnalysis {
  final Map<String, int> locationCounts;
  final List<GeoCoordinate> coordinates;
  final List<List<GeoCoordinate>> clusteredHotspots;
  final double coverageArea;

  GeographicAnalysis({
    required this.locationCounts,
    required this.coordinates,
    required this.clusteredHotspots,
    required this.coverageArea,
  });
}

class GeoCoordinate {
  final double latitude;
  final double longitude;
  final int count;

  GeoCoordinate({
    required this.latitude,
    required this.longitude,
    required this.count,
  });
}

class ReportHotspot {
  final GeoCoordinate center;
  final double radius;
  final int reportCount;
  final List<ReportCategory> categories;
  final double riskLevel;
  final Duration averageResolutionTime;

  ReportHotspot({
    required this.center,
    required this.radius,
    required this.reportCount,
    required this.categories,
    required this.riskLevel,
    required this.averageResolutionTime,
  });
}

class TemporalPatterns {
  final List<int> hourlyDistribution;
  final List<int> dailyDistribution;
  final List<int> monthlyDistribution;
  final int peakHour;
  final int peakDay;
  final int peakMonth;
  final double weekendVsWeekdayRatio;

  TemporalPatterns({
    required this.hourlyDistribution,
    required this.dailyDistribution,
    required this.monthlyDistribution,
    required this.peakHour,
    required this.peakDay,
    required this.peakMonth,
    required this.weekendVsWeekdayRatio,
  });
}

class ResolutionTimeAnalysis {
  final Duration averageResolutionTime;
  final Duration medianResolutionTime;
  final Map<ReportCategory, Duration> categoryResolutionTimes;
  final Map<ReportPriority, Duration> priorityResolutionTimes;

  ResolutionTimeAnalysis({
    required this.averageResolutionTime,
    required this.medianResolutionTime,
    required this.categoryResolutionTimes,
    required this.priorityResolutionTimes,
  });
}

class VolumePredicition {
  final int nextDay;
  final int nextWeek;
  final int nextMonth;
  final double confidence;
  final String trend;

  VolumePredicition({
    required this.nextDay,
    required this.nextWeek,
    required this.nextMonth,
    required this.confidence,
    required this.trend,
  });
}

class RiskAssessment {
  final String overallRiskLevel;
  final double riskScore;
  final int activeReportsCount;
  final int overdueReportsCount;
  final int highPriorityUnresolved;
  final List<ReportCategory> bottleneckCategories;
  final List<String> recommendedActions;

  RiskAssessment({
    required this.overallRiskLevel,
    required this.riskScore,
    required this.activeReportsCount,
    required this.overdueReportsCount,
    required this.highPriorityUnresolved,
    required this.bottleneckCategories,
    required this.recommendedActions,
  });
}

class SeasonalityPrediction {
  final int peakMonth;
  final int lowMonth;
  final double seasonalityStrength;
  final List<int> monthlyDistribution;

  SeasonalityPrediction({
    required this.peakMonth,
    required this.lowMonth,
    required this.seasonalityStrength,
    required this.monthlyDistribution,
  });
}

class QualityMetrics {
  final double completionRate;
  final double photoAttachmentRate;
  final double locationAccuracy;
  final Duration averageResponseTime;
  final double userSatisfactionScore;

  QualityMetrics({
    required this.completionRate,
    required this.photoAttachmentRate,
    required this.locationAccuracy,
    required this.averageResponseTime,
    required this.userSatisfactionScore,
  });
}

class UserEngagementMetrics {
  final int totalUniqueUsers;
  final int repeatUsers;
  final double averageReportsPerUser;
  final double engagementRate;

  UserEngagementMetrics({
    required this.totalUniqueUsers,
    required this.repeatUsers,
    required this.averageReportsPerUser,
    required this.engagementRate,
  });
}

class StatusTransition {
  final ReportStatus fromStatus;
  final ReportStatus toStatus;
  final int count;
  final Duration averageTime;

  StatusTransition({
    required this.fromStatus,
    required this.toStatus,
    required this.count,
    required this.averageTime,
  });
}

class AnalyticsRecommendation {
  final RecommendationType type;
  final String title;
  final String description;
  final String action;
  final RecommendationImpact impact;
  final ImplementationEffort implementationEffort;

  AnalyticsRecommendation({
    required this.type,
    required this.title,
    required this.description,
    required this.action,
    required this.impact,
    required this.implementationEffort,
  });
}

enum RecommendationType {
  urgent,
  processImprovement,
  preventive,
  efficiency,
  qualityImprovement,
}

enum RecommendationImpact { low, medium, high, critical }

enum ImplementationEffort { low, medium, high, veryHigh }

class AnalyticsResult {
  final dynamic data;
  final DateTime cachedAt;

  AnalyticsResult({required this.data, required this.cachedAt});

  bool get isExpired =>
      DateTime.now().difference(cachedAt) > const Duration(hours: 1);
}
