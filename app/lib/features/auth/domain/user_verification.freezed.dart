// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_verification.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TemporaryVerificationData _$TemporaryVerificationDataFromJson(
    Map<String, dynamic> json) {
  return _TemporaryVerificationData.fromJson(json);
}

/// @nodoc
mixin _$TemporaryVerificationData {
  String get fullName => throw _privateConstructorUsedError;
  String get address => throw _privateConstructorUsedError;
  String get zipCode => throw _privateConstructorUsedError;
  String get city => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get scheduledDeletionAt => throw _privateConstructorUsedError;
  String get consentHash => throw _privateConstructorUsedError;
  DateTime get consentGivenAt => throw _privateConstructorUsedError;
  String? get phoneNumber => throw _privateConstructorUsedError;
  String? get documentType => throw _privateConstructorUsedError;
  String? get documentNumber => throw _privateConstructorUsedError;
  String? get additionalInfo => throw _privateConstructorUsedError;
  double? get latitude => throw _privateConstructorUsedError;
  double? get longitude => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TemporaryVerificationDataCopyWith<TemporaryVerificationData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TemporaryVerificationDataCopyWith<$Res> {
  factory $TemporaryVerificationDataCopyWith(TemporaryVerificationData value,
          $Res Function(TemporaryVerificationData) then) =
      _$TemporaryVerificationDataCopyWithImpl<$Res, TemporaryVerificationData>;
  @useResult
  $Res call(
      {String fullName,
      String address,
      String zipCode,
      String city,
      DateTime createdAt,
      DateTime scheduledDeletionAt,
      String consentHash,
      DateTime consentGivenAt,
      String? phoneNumber,
      String? documentType,
      String? documentNumber,
      String? additionalInfo,
      double? latitude,
      double? longitude});
}

/// @nodoc
class _$TemporaryVerificationDataCopyWithImpl<$Res,
        $Val extends TemporaryVerificationData>
    implements $TemporaryVerificationDataCopyWith<$Res> {
  _$TemporaryVerificationDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fullName = null,
    Object? address = null,
    Object? zipCode = null,
    Object? city = null,
    Object? createdAt = null,
    Object? scheduledDeletionAt = null,
    Object? consentHash = null,
    Object? consentGivenAt = null,
    Object? phoneNumber = freezed,
    Object? documentType = freezed,
    Object? documentNumber = freezed,
    Object? additionalInfo = freezed,
    Object? latitude = freezed,
    Object? longitude = freezed,
  }) {
    return _then(_value.copyWith(
      fullName: null == fullName
          ? _value.fullName
          : fullName // ignore: cast_nullable_to_non_nullable
              as String,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      zipCode: null == zipCode
          ? _value.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String,
      city: null == city
          ? _value.city
          : city // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      scheduledDeletionAt: null == scheduledDeletionAt
          ? _value.scheduledDeletionAt
          : scheduledDeletionAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      consentHash: null == consentHash
          ? _value.consentHash
          : consentHash // ignore: cast_nullable_to_non_nullable
              as String,
      consentGivenAt: null == consentGivenAt
          ? _value.consentGivenAt
          : consentGivenAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      phoneNumber: freezed == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      documentType: freezed == documentType
          ? _value.documentType
          : documentType // ignore: cast_nullable_to_non_nullable
              as String?,
      documentNumber: freezed == documentNumber
          ? _value.documentNumber
          : documentNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInfo: freezed == additionalInfo
          ? _value.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TemporaryVerificationDataImplCopyWith<$Res>
    implements $TemporaryVerificationDataCopyWith<$Res> {
  factory _$$TemporaryVerificationDataImplCopyWith(
          _$TemporaryVerificationDataImpl value,
          $Res Function(_$TemporaryVerificationDataImpl) then) =
      __$$TemporaryVerificationDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String fullName,
      String address,
      String zipCode,
      String city,
      DateTime createdAt,
      DateTime scheduledDeletionAt,
      String consentHash,
      DateTime consentGivenAt,
      String? phoneNumber,
      String? documentType,
      String? documentNumber,
      String? additionalInfo,
      double? latitude,
      double? longitude});
}

/// @nodoc
class __$$TemporaryVerificationDataImplCopyWithImpl<$Res>
    extends _$TemporaryVerificationDataCopyWithImpl<$Res,
        _$TemporaryVerificationDataImpl>
    implements _$$TemporaryVerificationDataImplCopyWith<$Res> {
  __$$TemporaryVerificationDataImplCopyWithImpl(
      _$TemporaryVerificationDataImpl _value,
      $Res Function(_$TemporaryVerificationDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fullName = null,
    Object? address = null,
    Object? zipCode = null,
    Object? city = null,
    Object? createdAt = null,
    Object? scheduledDeletionAt = null,
    Object? consentHash = null,
    Object? consentGivenAt = null,
    Object? phoneNumber = freezed,
    Object? documentType = freezed,
    Object? documentNumber = freezed,
    Object? additionalInfo = freezed,
    Object? latitude = freezed,
    Object? longitude = freezed,
  }) {
    return _then(_$TemporaryVerificationDataImpl(
      fullName: null == fullName
          ? _value.fullName
          : fullName // ignore: cast_nullable_to_non_nullable
              as String,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      zipCode: null == zipCode
          ? _value.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String,
      city: null == city
          ? _value.city
          : city // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      scheduledDeletionAt: null == scheduledDeletionAt
          ? _value.scheduledDeletionAt
          : scheduledDeletionAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      consentHash: null == consentHash
          ? _value.consentHash
          : consentHash // ignore: cast_nullable_to_non_nullable
              as String,
      consentGivenAt: null == consentGivenAt
          ? _value.consentGivenAt
          : consentGivenAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      phoneNumber: freezed == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      documentType: freezed == documentType
          ? _value.documentType
          : documentType // ignore: cast_nullable_to_non_nullable
              as String?,
      documentNumber: freezed == documentNumber
          ? _value.documentNumber
          : documentNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInfo: freezed == additionalInfo
          ? _value.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TemporaryVerificationDataImpl implements _TemporaryVerificationData {
  const _$TemporaryVerificationDataImpl(
      {required this.fullName,
      required this.address,
      required this.zipCode,
      required this.city,
      required this.createdAt,
      required this.scheduledDeletionAt,
      required this.consentHash,
      required this.consentGivenAt,
      this.phoneNumber,
      this.documentType,
      this.documentNumber,
      this.additionalInfo,
      this.latitude,
      this.longitude});

  factory _$TemporaryVerificationDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$TemporaryVerificationDataImplFromJson(json);

  @override
  final String fullName;
  @override
  final String address;
  @override
  final String zipCode;
  @override
  final String city;
  @override
  final DateTime createdAt;
  @override
  final DateTime scheduledDeletionAt;
  @override
  final String consentHash;
  @override
  final DateTime consentGivenAt;
  @override
  final String? phoneNumber;
  @override
  final String? documentType;
  @override
  final String? documentNumber;
  @override
  final String? additionalInfo;
  @override
  final double? latitude;
  @override
  final double? longitude;

  @override
  String toString() {
    return 'TemporaryVerificationData(fullName: $fullName, address: $address, zipCode: $zipCode, city: $city, createdAt: $createdAt, scheduledDeletionAt: $scheduledDeletionAt, consentHash: $consentHash, consentGivenAt: $consentGivenAt, phoneNumber: $phoneNumber, documentType: $documentType, documentNumber: $documentNumber, additionalInfo: $additionalInfo, latitude: $latitude, longitude: $longitude)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TemporaryVerificationDataImpl &&
            (identical(other.fullName, fullName) ||
                other.fullName == fullName) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.zipCode, zipCode) || other.zipCode == zipCode) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.scheduledDeletionAt, scheduledDeletionAt) ||
                other.scheduledDeletionAt == scheduledDeletionAt) &&
            (identical(other.consentHash, consentHash) ||
                other.consentHash == consentHash) &&
            (identical(other.consentGivenAt, consentGivenAt) ||
                other.consentGivenAt == consentGivenAt) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.documentType, documentType) ||
                other.documentType == documentType) &&
            (identical(other.documentNumber, documentNumber) ||
                other.documentNumber == documentNumber) &&
            (identical(other.additionalInfo, additionalInfo) ||
                other.additionalInfo == additionalInfo) &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      fullName,
      address,
      zipCode,
      city,
      createdAt,
      scheduledDeletionAt,
      consentHash,
      consentGivenAt,
      phoneNumber,
      documentType,
      documentNumber,
      additionalInfo,
      latitude,
      longitude);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TemporaryVerificationDataImplCopyWith<_$TemporaryVerificationDataImpl>
      get copyWith => __$$TemporaryVerificationDataImplCopyWithImpl<
          _$TemporaryVerificationDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TemporaryVerificationDataImplToJson(
      this,
    );
  }
}

abstract class _TemporaryVerificationData implements TemporaryVerificationData {
  const factory _TemporaryVerificationData(
      {required final String fullName,
      required final String address,
      required final String zipCode,
      required final String city,
      required final DateTime createdAt,
      required final DateTime scheduledDeletionAt,
      required final String consentHash,
      required final DateTime consentGivenAt,
      final String? phoneNumber,
      final String? documentType,
      final String? documentNumber,
      final String? additionalInfo,
      final double? latitude,
      final double? longitude}) = _$TemporaryVerificationDataImpl;

  factory _TemporaryVerificationData.fromJson(Map<String, dynamic> json) =
      _$TemporaryVerificationDataImpl.fromJson;

  @override
  String get fullName;
  @override
  String get address;
  @override
  String get zipCode;
  @override
  String get city;
  @override
  DateTime get createdAt;
  @override
  DateTime get scheduledDeletionAt;
  @override
  String get consentHash;
  @override
  DateTime get consentGivenAt;
  @override
  String? get phoneNumber;
  @override
  String? get documentType;
  @override
  String? get documentNumber;
  @override
  String? get additionalInfo;
  @override
  double? get latitude;
  @override
  double? get longitude;
  @override
  @JsonKey(ignore: true)
  _$$TemporaryVerificationDataImplCopyWith<_$TemporaryVerificationDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VerificationAuditEntry _$VerificationAuditEntryFromJson(
    Map<String, dynamic> json) {
  return _VerificationAuditEntry.fromJson(json);
}

/// @nodoc
mixin _$VerificationAuditEntry {
  String get id => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  VerificationAction get action => throw _privateConstructorUsedError;
  String get performedBy => throw _privateConstructorUsedError;
  String? get reason => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VerificationAuditEntryCopyWith<VerificationAuditEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VerificationAuditEntryCopyWith<$Res> {
  factory $VerificationAuditEntryCopyWith(VerificationAuditEntry value,
          $Res Function(VerificationAuditEntry) then) =
      _$VerificationAuditEntryCopyWithImpl<$Res, VerificationAuditEntry>;
  @useResult
  $Res call(
      {String id,
      DateTime timestamp,
      VerificationAction action,
      String performedBy,
      String? reason,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$VerificationAuditEntryCopyWithImpl<$Res,
        $Val extends VerificationAuditEntry>
    implements $VerificationAuditEntryCopyWith<$Res> {
  _$VerificationAuditEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? timestamp = null,
    Object? action = null,
    Object? performedBy = null,
    Object? reason = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as VerificationAction,
      performedBy: null == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VerificationAuditEntryImplCopyWith<$Res>
    implements $VerificationAuditEntryCopyWith<$Res> {
  factory _$$VerificationAuditEntryImplCopyWith(
          _$VerificationAuditEntryImpl value,
          $Res Function(_$VerificationAuditEntryImpl) then) =
      __$$VerificationAuditEntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      DateTime timestamp,
      VerificationAction action,
      String performedBy,
      String? reason,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$VerificationAuditEntryImplCopyWithImpl<$Res>
    extends _$VerificationAuditEntryCopyWithImpl<$Res,
        _$VerificationAuditEntryImpl>
    implements _$$VerificationAuditEntryImplCopyWith<$Res> {
  __$$VerificationAuditEntryImplCopyWithImpl(
      _$VerificationAuditEntryImpl _value,
      $Res Function(_$VerificationAuditEntryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? timestamp = null,
    Object? action = null,
    Object? performedBy = null,
    Object? reason = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$VerificationAuditEntryImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as VerificationAction,
      performedBy: null == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VerificationAuditEntryImpl implements _VerificationAuditEntry {
  const _$VerificationAuditEntryImpl(
      {required this.id,
      required this.timestamp,
      required this.action,
      required this.performedBy,
      this.reason,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata;

  factory _$VerificationAuditEntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$VerificationAuditEntryImplFromJson(json);

  @override
  final String id;
  @override
  final DateTime timestamp;
  @override
  final VerificationAction action;
  @override
  final String performedBy;
  @override
  final String? reason;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'VerificationAuditEntry(id: $id, timestamp: $timestamp, action: $action, performedBy: $performedBy, reason: $reason, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VerificationAuditEntryImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.action, action) || other.action == action) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, timestamp, action,
      performedBy, reason, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VerificationAuditEntryImplCopyWith<_$VerificationAuditEntryImpl>
      get copyWith => __$$VerificationAuditEntryImplCopyWithImpl<
          _$VerificationAuditEntryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VerificationAuditEntryImplToJson(
      this,
    );
  }
}

abstract class _VerificationAuditEntry implements VerificationAuditEntry {
  const factory _VerificationAuditEntry(
      {required final String id,
      required final DateTime timestamp,
      required final VerificationAction action,
      required final String performedBy,
      final String? reason,
      final Map<String, dynamic>? metadata}) = _$VerificationAuditEntryImpl;

  factory _VerificationAuditEntry.fromJson(Map<String, dynamic> json) =
      _$VerificationAuditEntryImpl.fromJson;

  @override
  String get id;
  @override
  DateTime get timestamp;
  @override
  VerificationAction get action;
  @override
  String get performedBy;
  @override
  String? get reason;
  @override
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$VerificationAuditEntryImplCopyWith<_$VerificationAuditEntryImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ResidentVerification _$ResidentVerificationFromJson(Map<String, dynamic> json) {
  return _ResidentVerification.fromJson(json);
}

/// @nodoc
mixin _$ResidentVerification {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  VerificationStatus get status => throw _privateConstructorUsedError;
  DateTime get submittedAt => throw _privateConstructorUsedError;
  DateTime get dataWillBeDeletedAt => throw _privateConstructorUsedError;
  List<VerificationAuditEntry> get auditTrail =>
      throw _privateConstructorUsedError;
  TemporaryVerificationData? get temporaryData =>
      throw _privateConstructorUsedError;
  DateTime? get verifiedAt => throw _privateConstructorUsedError;
  String? get adminNotes => throw _privateConstructorUsedError;
  String? get rejectionReason => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResidentVerificationCopyWith<ResidentVerification> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResidentVerificationCopyWith<$Res> {
  factory $ResidentVerificationCopyWith(ResidentVerification value,
          $Res Function(ResidentVerification) then) =
      _$ResidentVerificationCopyWithImpl<$Res, ResidentVerification>;
  @useResult
  $Res call(
      {String id,
      String userId,
      VerificationStatus status,
      DateTime submittedAt,
      DateTime dataWillBeDeletedAt,
      List<VerificationAuditEntry> auditTrail,
      TemporaryVerificationData? temporaryData,
      DateTime? verifiedAt,
      String? adminNotes,
      String? rejectionReason});

  $TemporaryVerificationDataCopyWith<$Res>? get temporaryData;
}

/// @nodoc
class _$ResidentVerificationCopyWithImpl<$Res,
        $Val extends ResidentVerification>
    implements $ResidentVerificationCopyWith<$Res> {
  _$ResidentVerificationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? status = null,
    Object? submittedAt = null,
    Object? dataWillBeDeletedAt = null,
    Object? auditTrail = null,
    Object? temporaryData = freezed,
    Object? verifiedAt = freezed,
    Object? adminNotes = freezed,
    Object? rejectionReason = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VerificationStatus,
      submittedAt: null == submittedAt
          ? _value.submittedAt
          : submittedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      dataWillBeDeletedAt: null == dataWillBeDeletedAt
          ? _value.dataWillBeDeletedAt
          : dataWillBeDeletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      auditTrail: null == auditTrail
          ? _value.auditTrail
          : auditTrail // ignore: cast_nullable_to_non_nullable
              as List<VerificationAuditEntry>,
      temporaryData: freezed == temporaryData
          ? _value.temporaryData
          : temporaryData // ignore: cast_nullable_to_non_nullable
              as TemporaryVerificationData?,
      verifiedAt: freezed == verifiedAt
          ? _value.verifiedAt
          : verifiedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      adminNotes: freezed == adminNotes
          ? _value.adminNotes
          : adminNotes // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectionReason: freezed == rejectionReason
          ? _value.rejectionReason
          : rejectionReason // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TemporaryVerificationDataCopyWith<$Res>? get temporaryData {
    if (_value.temporaryData == null) {
      return null;
    }

    return $TemporaryVerificationDataCopyWith<$Res>(_value.temporaryData!,
        (value) {
      return _then(_value.copyWith(temporaryData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ResidentVerificationImplCopyWith<$Res>
    implements $ResidentVerificationCopyWith<$Res> {
  factory _$$ResidentVerificationImplCopyWith(_$ResidentVerificationImpl value,
          $Res Function(_$ResidentVerificationImpl) then) =
      __$$ResidentVerificationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      VerificationStatus status,
      DateTime submittedAt,
      DateTime dataWillBeDeletedAt,
      List<VerificationAuditEntry> auditTrail,
      TemporaryVerificationData? temporaryData,
      DateTime? verifiedAt,
      String? adminNotes,
      String? rejectionReason});

  @override
  $TemporaryVerificationDataCopyWith<$Res>? get temporaryData;
}

/// @nodoc
class __$$ResidentVerificationImplCopyWithImpl<$Res>
    extends _$ResidentVerificationCopyWithImpl<$Res, _$ResidentVerificationImpl>
    implements _$$ResidentVerificationImplCopyWith<$Res> {
  __$$ResidentVerificationImplCopyWithImpl(_$ResidentVerificationImpl _value,
      $Res Function(_$ResidentVerificationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? status = null,
    Object? submittedAt = null,
    Object? dataWillBeDeletedAt = null,
    Object? auditTrail = null,
    Object? temporaryData = freezed,
    Object? verifiedAt = freezed,
    Object? adminNotes = freezed,
    Object? rejectionReason = freezed,
  }) {
    return _then(_$ResidentVerificationImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VerificationStatus,
      submittedAt: null == submittedAt
          ? _value.submittedAt
          : submittedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      dataWillBeDeletedAt: null == dataWillBeDeletedAt
          ? _value.dataWillBeDeletedAt
          : dataWillBeDeletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      auditTrail: null == auditTrail
          ? _value._auditTrail
          : auditTrail // ignore: cast_nullable_to_non_nullable
              as List<VerificationAuditEntry>,
      temporaryData: freezed == temporaryData
          ? _value.temporaryData
          : temporaryData // ignore: cast_nullable_to_non_nullable
              as TemporaryVerificationData?,
      verifiedAt: freezed == verifiedAt
          ? _value.verifiedAt
          : verifiedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      adminNotes: freezed == adminNotes
          ? _value.adminNotes
          : adminNotes // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectionReason: freezed == rejectionReason
          ? _value.rejectionReason
          : rejectionReason // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResidentVerificationImpl implements _ResidentVerification {
  const _$ResidentVerificationImpl(
      {required this.id,
      required this.userId,
      required this.status,
      required this.submittedAt,
      required this.dataWillBeDeletedAt,
      required final List<VerificationAuditEntry> auditTrail,
      this.temporaryData,
      this.verifiedAt,
      this.adminNotes,
      this.rejectionReason})
      : _auditTrail = auditTrail;

  factory _$ResidentVerificationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResidentVerificationImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final VerificationStatus status;
  @override
  final DateTime submittedAt;
  @override
  final DateTime dataWillBeDeletedAt;
  final List<VerificationAuditEntry> _auditTrail;
  @override
  List<VerificationAuditEntry> get auditTrail {
    if (_auditTrail is EqualUnmodifiableListView) return _auditTrail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_auditTrail);
  }

  @override
  final TemporaryVerificationData? temporaryData;
  @override
  final DateTime? verifiedAt;
  @override
  final String? adminNotes;
  @override
  final String? rejectionReason;

  @override
  String toString() {
    return 'ResidentVerification(id: $id, userId: $userId, status: $status, submittedAt: $submittedAt, dataWillBeDeletedAt: $dataWillBeDeletedAt, auditTrail: $auditTrail, temporaryData: $temporaryData, verifiedAt: $verifiedAt, adminNotes: $adminNotes, rejectionReason: $rejectionReason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResidentVerificationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.submittedAt, submittedAt) ||
                other.submittedAt == submittedAt) &&
            (identical(other.dataWillBeDeletedAt, dataWillBeDeletedAt) ||
                other.dataWillBeDeletedAt == dataWillBeDeletedAt) &&
            const DeepCollectionEquality()
                .equals(other._auditTrail, _auditTrail) &&
            (identical(other.temporaryData, temporaryData) ||
                other.temporaryData == temporaryData) &&
            (identical(other.verifiedAt, verifiedAt) ||
                other.verifiedAt == verifiedAt) &&
            (identical(other.adminNotes, adminNotes) ||
                other.adminNotes == adminNotes) &&
            (identical(other.rejectionReason, rejectionReason) ||
                other.rejectionReason == rejectionReason));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      userId,
      status,
      submittedAt,
      dataWillBeDeletedAt,
      const DeepCollectionEquality().hash(_auditTrail),
      temporaryData,
      verifiedAt,
      adminNotes,
      rejectionReason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResidentVerificationImplCopyWith<_$ResidentVerificationImpl>
      get copyWith =>
          __$$ResidentVerificationImplCopyWithImpl<_$ResidentVerificationImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ResidentVerificationImplToJson(
      this,
    );
  }
}

abstract class _ResidentVerification implements ResidentVerification {
  const factory _ResidentVerification(
      {required final String id,
      required final String userId,
      required final VerificationStatus status,
      required final DateTime submittedAt,
      required final DateTime dataWillBeDeletedAt,
      required final List<VerificationAuditEntry> auditTrail,
      final TemporaryVerificationData? temporaryData,
      final DateTime? verifiedAt,
      final String? adminNotes,
      final String? rejectionReason}) = _$ResidentVerificationImpl;

  factory _ResidentVerification.fromJson(Map<String, dynamic> json) =
      _$ResidentVerificationImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  VerificationStatus get status;
  @override
  DateTime get submittedAt;
  @override
  DateTime get dataWillBeDeletedAt;
  @override
  List<VerificationAuditEntry> get auditTrail;
  @override
  TemporaryVerificationData? get temporaryData;
  @override
  DateTime? get verifiedAt;
  @override
  String? get adminNotes;
  @override
  String? get rejectionReason;
  @override
  @JsonKey(ignore: true)
  _$$ResidentVerificationImplCopyWith<_$ResidentVerificationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ConsentAuditEntry _$ConsentAuditEntryFromJson(Map<String, dynamic> json) {
  return _ConsentAuditEntry.fromJson(json);
}

/// @nodoc
mixin _$ConsentAuditEntry {
  String get id => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  ConsentAction get action => throw _privateConstructorUsedError;
  ConsentSource get source => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConsentAuditEntryCopyWith<ConsentAuditEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConsentAuditEntryCopyWith<$Res> {
  factory $ConsentAuditEntryCopyWith(
          ConsentAuditEntry value, $Res Function(ConsentAuditEntry) then) =
      _$ConsentAuditEntryCopyWithImpl<$Res, ConsentAuditEntry>;
  @useResult
  $Res call(
      {String id,
      DateTime timestamp,
      ConsentAction action,
      ConsentSource source,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ConsentAuditEntryCopyWithImpl<$Res, $Val extends ConsentAuditEntry>
    implements $ConsentAuditEntryCopyWith<$Res> {
  _$ConsentAuditEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? timestamp = null,
    Object? action = null,
    Object? source = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as ConsentAction,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ConsentSource,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ConsentAuditEntryImplCopyWith<$Res>
    implements $ConsentAuditEntryCopyWith<$Res> {
  factory _$$ConsentAuditEntryImplCopyWith(_$ConsentAuditEntryImpl value,
          $Res Function(_$ConsentAuditEntryImpl) then) =
      __$$ConsentAuditEntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      DateTime timestamp,
      ConsentAction action,
      ConsentSource source,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ConsentAuditEntryImplCopyWithImpl<$Res>
    extends _$ConsentAuditEntryCopyWithImpl<$Res, _$ConsentAuditEntryImpl>
    implements _$$ConsentAuditEntryImplCopyWith<$Res> {
  __$$ConsentAuditEntryImplCopyWithImpl(_$ConsentAuditEntryImpl _value,
      $Res Function(_$ConsentAuditEntryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? timestamp = null,
    Object? action = null,
    Object? source = null,
    Object? metadata = freezed,
  }) {
    return _then(_$ConsentAuditEntryImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as ConsentAction,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ConsentSource,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ConsentAuditEntryImpl implements _ConsentAuditEntry {
  const _$ConsentAuditEntryImpl(
      {required this.id,
      required this.timestamp,
      required this.action,
      required this.source,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata;

  factory _$ConsentAuditEntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$ConsentAuditEntryImplFromJson(json);

  @override
  final String id;
  @override
  final DateTime timestamp;
  @override
  final ConsentAction action;
  @override
  final ConsentSource source;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ConsentAuditEntry(id: $id, timestamp: $timestamp, action: $action, source: $source, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConsentAuditEntryImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.action, action) || other.action == action) &&
            (identical(other.source, source) || other.source == source) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, timestamp, action, source,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConsentAuditEntryImplCopyWith<_$ConsentAuditEntryImpl> get copyWith =>
      __$$ConsentAuditEntryImplCopyWithImpl<_$ConsentAuditEntryImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ConsentAuditEntryImplToJson(
      this,
    );
  }
}

abstract class _ConsentAuditEntry implements ConsentAuditEntry {
  const factory _ConsentAuditEntry(
      {required final String id,
      required final DateTime timestamp,
      required final ConsentAction action,
      required final ConsentSource source,
      final Map<String, dynamic>? metadata}) = _$ConsentAuditEntryImpl;

  factory _ConsentAuditEntry.fromJson(Map<String, dynamic> json) =
      _$ConsentAuditEntryImpl.fromJson;

  @override
  String get id;
  @override
  DateTime get timestamp;
  @override
  ConsentAction get action;
  @override
  ConsentSource get source;
  @override
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ConsentAuditEntryImplCopyWith<_$ConsentAuditEntryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DataProcessingConsent _$DataProcessingConsentFromJson(
    Map<String, dynamic> json) {
  return _DataProcessingConsent.fromJson(json);
}

/// @nodoc
mixin _$DataProcessingConsent {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  ConsentType get consentType => throw _privateConstructorUsedError;
  bool get granted => throw _privateConstructorUsedError;
  DateTime get grantedAt => throw _privateConstructorUsedError;
  ConsentSource get source => throw _privateConstructorUsedError;
  String get purpose => throw _privateConstructorUsedError;
  String get legalBasis => throw _privateConstructorUsedError;
  DateTime get validUntil => throw _privateConstructorUsedError;
  String get ipAddress => throw _privateConstructorUsedError;
  String get userAgent => throw _privateConstructorUsedError;
  String get consentVersion => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;
  List<ConsentAuditEntry> get auditTrail => throw _privateConstructorUsedError;
  DateTime? get withdrawnAt => throw _privateConstructorUsedError;
  DateTime? get renewedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DataProcessingConsentCopyWith<DataProcessingConsent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataProcessingConsentCopyWith<$Res> {
  factory $DataProcessingConsentCopyWith(DataProcessingConsent value,
          $Res Function(DataProcessingConsent) then) =
      _$DataProcessingConsentCopyWithImpl<$Res, DataProcessingConsent>;
  @useResult
  $Res call(
      {String id,
      String userId,
      ConsentType consentType,
      bool granted,
      DateTime grantedAt,
      ConsentSource source,
      String purpose,
      String legalBasis,
      DateTime validUntil,
      String ipAddress,
      String userAgent,
      String consentVersion,
      Map<String, dynamic> metadata,
      List<ConsentAuditEntry> auditTrail,
      DateTime? withdrawnAt,
      DateTime? renewedAt});
}

/// @nodoc
class _$DataProcessingConsentCopyWithImpl<$Res,
        $Val extends DataProcessingConsent>
    implements $DataProcessingConsentCopyWith<$Res> {
  _$DataProcessingConsentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? consentType = null,
    Object? granted = null,
    Object? grantedAt = null,
    Object? source = null,
    Object? purpose = null,
    Object? legalBasis = null,
    Object? validUntil = null,
    Object? ipAddress = null,
    Object? userAgent = null,
    Object? consentVersion = null,
    Object? metadata = null,
    Object? auditTrail = null,
    Object? withdrawnAt = freezed,
    Object? renewedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      consentType: null == consentType
          ? _value.consentType
          : consentType // ignore: cast_nullable_to_non_nullable
              as ConsentType,
      granted: null == granted
          ? _value.granted
          : granted // ignore: cast_nullable_to_non_nullable
              as bool,
      grantedAt: null == grantedAt
          ? _value.grantedAt
          : grantedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ConsentSource,
      purpose: null == purpose
          ? _value.purpose
          : purpose // ignore: cast_nullable_to_non_nullable
              as String,
      legalBasis: null == legalBasis
          ? _value.legalBasis
          : legalBasis // ignore: cast_nullable_to_non_nullable
              as String,
      validUntil: null == validUntil
          ? _value.validUntil
          : validUntil // ignore: cast_nullable_to_non_nullable
              as DateTime,
      ipAddress: null == ipAddress
          ? _value.ipAddress
          : ipAddress // ignore: cast_nullable_to_non_nullable
              as String,
      userAgent: null == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String,
      consentVersion: null == consentVersion
          ? _value.consentVersion
          : consentVersion // ignore: cast_nullable_to_non_nullable
              as String,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      auditTrail: null == auditTrail
          ? _value.auditTrail
          : auditTrail // ignore: cast_nullable_to_non_nullable
              as List<ConsentAuditEntry>,
      withdrawnAt: freezed == withdrawnAt
          ? _value.withdrawnAt
          : withdrawnAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      renewedAt: freezed == renewedAt
          ? _value.renewedAt
          : renewedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DataProcessingConsentImplCopyWith<$Res>
    implements $DataProcessingConsentCopyWith<$Res> {
  factory _$$DataProcessingConsentImplCopyWith(
          _$DataProcessingConsentImpl value,
          $Res Function(_$DataProcessingConsentImpl) then) =
      __$$DataProcessingConsentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      ConsentType consentType,
      bool granted,
      DateTime grantedAt,
      ConsentSource source,
      String purpose,
      String legalBasis,
      DateTime validUntil,
      String ipAddress,
      String userAgent,
      String consentVersion,
      Map<String, dynamic> metadata,
      List<ConsentAuditEntry> auditTrail,
      DateTime? withdrawnAt,
      DateTime? renewedAt});
}

/// @nodoc
class __$$DataProcessingConsentImplCopyWithImpl<$Res>
    extends _$DataProcessingConsentCopyWithImpl<$Res,
        _$DataProcessingConsentImpl>
    implements _$$DataProcessingConsentImplCopyWith<$Res> {
  __$$DataProcessingConsentImplCopyWithImpl(_$DataProcessingConsentImpl _value,
      $Res Function(_$DataProcessingConsentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? consentType = null,
    Object? granted = null,
    Object? grantedAt = null,
    Object? source = null,
    Object? purpose = null,
    Object? legalBasis = null,
    Object? validUntil = null,
    Object? ipAddress = null,
    Object? userAgent = null,
    Object? consentVersion = null,
    Object? metadata = null,
    Object? auditTrail = null,
    Object? withdrawnAt = freezed,
    Object? renewedAt = freezed,
  }) {
    return _then(_$DataProcessingConsentImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      consentType: null == consentType
          ? _value.consentType
          : consentType // ignore: cast_nullable_to_non_nullable
              as ConsentType,
      granted: null == granted
          ? _value.granted
          : granted // ignore: cast_nullable_to_non_nullable
              as bool,
      grantedAt: null == grantedAt
          ? _value.grantedAt
          : grantedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ConsentSource,
      purpose: null == purpose
          ? _value.purpose
          : purpose // ignore: cast_nullable_to_non_nullable
              as String,
      legalBasis: null == legalBasis
          ? _value.legalBasis
          : legalBasis // ignore: cast_nullable_to_non_nullable
              as String,
      validUntil: null == validUntil
          ? _value.validUntil
          : validUntil // ignore: cast_nullable_to_non_nullable
              as DateTime,
      ipAddress: null == ipAddress
          ? _value.ipAddress
          : ipAddress // ignore: cast_nullable_to_non_nullable
              as String,
      userAgent: null == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String,
      consentVersion: null == consentVersion
          ? _value.consentVersion
          : consentVersion // ignore: cast_nullable_to_non_nullable
              as String,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      auditTrail: null == auditTrail
          ? _value._auditTrail
          : auditTrail // ignore: cast_nullable_to_non_nullable
              as List<ConsentAuditEntry>,
      withdrawnAt: freezed == withdrawnAt
          ? _value.withdrawnAt
          : withdrawnAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      renewedAt: freezed == renewedAt
          ? _value.renewedAt
          : renewedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DataProcessingConsentImpl implements _DataProcessingConsent {
  const _$DataProcessingConsentImpl(
      {required this.id,
      required this.userId,
      required this.consentType,
      required this.granted,
      required this.grantedAt,
      required this.source,
      required this.purpose,
      required this.legalBasis,
      required this.validUntil,
      required this.ipAddress,
      required this.userAgent,
      required this.consentVersion,
      required final Map<String, dynamic> metadata,
      required final List<ConsentAuditEntry> auditTrail,
      this.withdrawnAt,
      this.renewedAt})
      : _metadata = metadata,
        _auditTrail = auditTrail;

  factory _$DataProcessingConsentImpl.fromJson(Map<String, dynamic> json) =>
      _$$DataProcessingConsentImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final ConsentType consentType;
  @override
  final bool granted;
  @override
  final DateTime grantedAt;
  @override
  final ConsentSource source;
  @override
  final String purpose;
  @override
  final String legalBasis;
  @override
  final DateTime validUntil;
  @override
  final String ipAddress;
  @override
  final String userAgent;
  @override
  final String consentVersion;
  final Map<String, dynamic> _metadata;
  @override
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  final List<ConsentAuditEntry> _auditTrail;
  @override
  List<ConsentAuditEntry> get auditTrail {
    if (_auditTrail is EqualUnmodifiableListView) return _auditTrail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_auditTrail);
  }

  @override
  final DateTime? withdrawnAt;
  @override
  final DateTime? renewedAt;

  @override
  String toString() {
    return 'DataProcessingConsent(id: $id, userId: $userId, consentType: $consentType, granted: $granted, grantedAt: $grantedAt, source: $source, purpose: $purpose, legalBasis: $legalBasis, validUntil: $validUntil, ipAddress: $ipAddress, userAgent: $userAgent, consentVersion: $consentVersion, metadata: $metadata, auditTrail: $auditTrail, withdrawnAt: $withdrawnAt, renewedAt: $renewedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataProcessingConsentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.consentType, consentType) ||
                other.consentType == consentType) &&
            (identical(other.granted, granted) || other.granted == granted) &&
            (identical(other.grantedAt, grantedAt) ||
                other.grantedAt == grantedAt) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.purpose, purpose) || other.purpose == purpose) &&
            (identical(other.legalBasis, legalBasis) ||
                other.legalBasis == legalBasis) &&
            (identical(other.validUntil, validUntil) ||
                other.validUntil == validUntil) &&
            (identical(other.ipAddress, ipAddress) ||
                other.ipAddress == ipAddress) &&
            (identical(other.userAgent, userAgent) ||
                other.userAgent == userAgent) &&
            (identical(other.consentVersion, consentVersion) ||
                other.consentVersion == consentVersion) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            const DeepCollectionEquality()
                .equals(other._auditTrail, _auditTrail) &&
            (identical(other.withdrawnAt, withdrawnAt) ||
                other.withdrawnAt == withdrawnAt) &&
            (identical(other.renewedAt, renewedAt) ||
                other.renewedAt == renewedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      userId,
      consentType,
      granted,
      grantedAt,
      source,
      purpose,
      legalBasis,
      validUntil,
      ipAddress,
      userAgent,
      consentVersion,
      const DeepCollectionEquality().hash(_metadata),
      const DeepCollectionEquality().hash(_auditTrail),
      withdrawnAt,
      renewedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataProcessingConsentImplCopyWith<_$DataProcessingConsentImpl>
      get copyWith => __$$DataProcessingConsentImplCopyWithImpl<
          _$DataProcessingConsentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DataProcessingConsentImplToJson(
      this,
    );
  }
}

abstract class _DataProcessingConsent implements DataProcessingConsent {
  const factory _DataProcessingConsent(
      {required final String id,
      required final String userId,
      required final ConsentType consentType,
      required final bool granted,
      required final DateTime grantedAt,
      required final ConsentSource source,
      required final String purpose,
      required final String legalBasis,
      required final DateTime validUntil,
      required final String ipAddress,
      required final String userAgent,
      required final String consentVersion,
      required final Map<String, dynamic> metadata,
      required final List<ConsentAuditEntry> auditTrail,
      final DateTime? withdrawnAt,
      final DateTime? renewedAt}) = _$DataProcessingConsentImpl;

  factory _DataProcessingConsent.fromJson(Map<String, dynamic> json) =
      _$DataProcessingConsentImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  ConsentType get consentType;
  @override
  bool get granted;
  @override
  DateTime get grantedAt;
  @override
  ConsentSource get source;
  @override
  String get purpose;
  @override
  String get legalBasis;
  @override
  DateTime get validUntil;
  @override
  String get ipAddress;
  @override
  String get userAgent;
  @override
  String get consentVersion;
  @override
  Map<String, dynamic> get metadata;
  @override
  List<ConsentAuditEntry> get auditTrail;
  @override
  DateTime? get withdrawnAt;
  @override
  DateTime? get renewedAt;
  @override
  @JsonKey(ignore: true)
  _$$DataProcessingConsentImplCopyWith<_$DataProcessingConsentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DataAccessRequest _$DataAccessRequestFromJson(Map<String, dynamic> json) {
  return _DataAccessRequest.fromJson(json);
}

/// @nodoc
mixin _$DataAccessRequest {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  DataAccessType get requestType => throw _privateConstructorUsedError;
  DateTime get requestedAt => throw _privateConstructorUsedError;
  DataAccessStatus get status => throw _privateConstructorUsedError;
  DateTime? get processedAt => throw _privateConstructorUsedError;
  String? get responseData => throw _privateConstructorUsedError;
  String? get processingNotes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DataAccessRequestCopyWith<DataAccessRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataAccessRequestCopyWith<$Res> {
  factory $DataAccessRequestCopyWith(
          DataAccessRequest value, $Res Function(DataAccessRequest) then) =
      _$DataAccessRequestCopyWithImpl<$Res, DataAccessRequest>;
  @useResult
  $Res call(
      {String id,
      String userId,
      DataAccessType requestType,
      DateTime requestedAt,
      DataAccessStatus status,
      DateTime? processedAt,
      String? responseData,
      String? processingNotes});
}

/// @nodoc
class _$DataAccessRequestCopyWithImpl<$Res, $Val extends DataAccessRequest>
    implements $DataAccessRequestCopyWith<$Res> {
  _$DataAccessRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? requestType = null,
    Object? requestedAt = null,
    Object? status = null,
    Object? processedAt = freezed,
    Object? responseData = freezed,
    Object? processingNotes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      requestType: null == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as DataAccessType,
      requestedAt: null == requestedAt
          ? _value.requestedAt
          : requestedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as DataAccessStatus,
      processedAt: freezed == processedAt
          ? _value.processedAt
          : processedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      responseData: freezed == responseData
          ? _value.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as String?,
      processingNotes: freezed == processingNotes
          ? _value.processingNotes
          : processingNotes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DataAccessRequestImplCopyWith<$Res>
    implements $DataAccessRequestCopyWith<$Res> {
  factory _$$DataAccessRequestImplCopyWith(_$DataAccessRequestImpl value,
          $Res Function(_$DataAccessRequestImpl) then) =
      __$$DataAccessRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      DataAccessType requestType,
      DateTime requestedAt,
      DataAccessStatus status,
      DateTime? processedAt,
      String? responseData,
      String? processingNotes});
}

/// @nodoc
class __$$DataAccessRequestImplCopyWithImpl<$Res>
    extends _$DataAccessRequestCopyWithImpl<$Res, _$DataAccessRequestImpl>
    implements _$$DataAccessRequestImplCopyWith<$Res> {
  __$$DataAccessRequestImplCopyWithImpl(_$DataAccessRequestImpl _value,
      $Res Function(_$DataAccessRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? requestType = null,
    Object? requestedAt = null,
    Object? status = null,
    Object? processedAt = freezed,
    Object? responseData = freezed,
    Object? processingNotes = freezed,
  }) {
    return _then(_$DataAccessRequestImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      requestType: null == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as DataAccessType,
      requestedAt: null == requestedAt
          ? _value.requestedAt
          : requestedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as DataAccessStatus,
      processedAt: freezed == processedAt
          ? _value.processedAt
          : processedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      responseData: freezed == responseData
          ? _value.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as String?,
      processingNotes: freezed == processingNotes
          ? _value.processingNotes
          : processingNotes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DataAccessRequestImpl implements _DataAccessRequest {
  const _$DataAccessRequestImpl(
      {required this.id,
      required this.userId,
      required this.requestType,
      required this.requestedAt,
      required this.status,
      this.processedAt,
      this.responseData,
      this.processingNotes});

  factory _$DataAccessRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$DataAccessRequestImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final DataAccessType requestType;
  @override
  final DateTime requestedAt;
  @override
  final DataAccessStatus status;
  @override
  final DateTime? processedAt;
  @override
  final String? responseData;
  @override
  final String? processingNotes;

  @override
  String toString() {
    return 'DataAccessRequest(id: $id, userId: $userId, requestType: $requestType, requestedAt: $requestedAt, status: $status, processedAt: $processedAt, responseData: $responseData, processingNotes: $processingNotes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataAccessRequestImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.requestType, requestType) ||
                other.requestType == requestType) &&
            (identical(other.requestedAt, requestedAt) ||
                other.requestedAt == requestedAt) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.processedAt, processedAt) ||
                other.processedAt == processedAt) &&
            (identical(other.responseData, responseData) ||
                other.responseData == responseData) &&
            (identical(other.processingNotes, processingNotes) ||
                other.processingNotes == processingNotes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, userId, requestType,
      requestedAt, status, processedAt, responseData, processingNotes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataAccessRequestImplCopyWith<_$DataAccessRequestImpl> get copyWith =>
      __$$DataAccessRequestImplCopyWithImpl<_$DataAccessRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DataAccessRequestImplToJson(
      this,
    );
  }
}

abstract class _DataAccessRequest implements DataAccessRequest {
  const factory _DataAccessRequest(
      {required final String id,
      required final String userId,
      required final DataAccessType requestType,
      required final DateTime requestedAt,
      required final DataAccessStatus status,
      final DateTime? processedAt,
      final String? responseData,
      final String? processingNotes}) = _$DataAccessRequestImpl;

  factory _DataAccessRequest.fromJson(Map<String, dynamic> json) =
      _$DataAccessRequestImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  DataAccessType get requestType;
  @override
  DateTime get requestedAt;
  @override
  DataAccessStatus get status;
  @override
  DateTime? get processedAt;
  @override
  String? get responseData;
  @override
  String? get processingNotes;
  @override
  @JsonKey(ignore: true)
  _$$DataAccessRequestImplCopyWith<_$DataAccessRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LocationCheck _$LocationCheckFromJson(Map<String, dynamic> json) {
  return _LocationCheck.fromJson(json);
}

/// @nodoc
mixin _$LocationCheck {
  String get id => throw _privateConstructorUsedError;
  String get verificationId => throw _privateConstructorUsedError;
  DateTime get checkTime => throw _privateConstructorUsedError;
  double get latitude => throw _privateConstructorUsedError;
  double get longitude => throw _privateConstructorUsedError;
  double get accuracy => throw _privateConstructorUsedError;
  bool get isAtAddress => throw _privateConstructorUsedError;
  double get distanceToAddress => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LocationCheckCopyWith<LocationCheck> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationCheckCopyWith<$Res> {
  factory $LocationCheckCopyWith(
          LocationCheck value, $Res Function(LocationCheck) then) =
      _$LocationCheckCopyWithImpl<$Res, LocationCheck>;
  @useResult
  $Res call(
      {String id,
      String verificationId,
      DateTime checkTime,
      double latitude,
      double longitude,
      double accuracy,
      bool isAtAddress,
      double distanceToAddress,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$LocationCheckCopyWithImpl<$Res, $Val extends LocationCheck>
    implements $LocationCheckCopyWith<$Res> {
  _$LocationCheckCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? verificationId = null,
    Object? checkTime = null,
    Object? latitude = null,
    Object? longitude = null,
    Object? accuracy = null,
    Object? isAtAddress = null,
    Object? distanceToAddress = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      verificationId: null == verificationId
          ? _value.verificationId
          : verificationId // ignore: cast_nullable_to_non_nullable
              as String,
      checkTime: null == checkTime
          ? _value.checkTime
          : checkTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
      accuracy: null == accuracy
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as double,
      isAtAddress: null == isAtAddress
          ? _value.isAtAddress
          : isAtAddress // ignore: cast_nullable_to_non_nullable
              as bool,
      distanceToAddress: null == distanceToAddress
          ? _value.distanceToAddress
          : distanceToAddress // ignore: cast_nullable_to_non_nullable
              as double,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LocationCheckImplCopyWith<$Res>
    implements $LocationCheckCopyWith<$Res> {
  factory _$$LocationCheckImplCopyWith(
          _$LocationCheckImpl value, $Res Function(_$LocationCheckImpl) then) =
      __$$LocationCheckImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String verificationId,
      DateTime checkTime,
      double latitude,
      double longitude,
      double accuracy,
      bool isAtAddress,
      double distanceToAddress,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$LocationCheckImplCopyWithImpl<$Res>
    extends _$LocationCheckCopyWithImpl<$Res, _$LocationCheckImpl>
    implements _$$LocationCheckImplCopyWith<$Res> {
  __$$LocationCheckImplCopyWithImpl(
      _$LocationCheckImpl _value, $Res Function(_$LocationCheckImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? verificationId = null,
    Object? checkTime = null,
    Object? latitude = null,
    Object? longitude = null,
    Object? accuracy = null,
    Object? isAtAddress = null,
    Object? distanceToAddress = null,
    Object? metadata = freezed,
  }) {
    return _then(_$LocationCheckImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      verificationId: null == verificationId
          ? _value.verificationId
          : verificationId // ignore: cast_nullable_to_non_nullable
              as String,
      checkTime: null == checkTime
          ? _value.checkTime
          : checkTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
      accuracy: null == accuracy
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as double,
      isAtAddress: null == isAtAddress
          ? _value.isAtAddress
          : isAtAddress // ignore: cast_nullable_to_non_nullable
              as bool,
      distanceToAddress: null == distanceToAddress
          ? _value.distanceToAddress
          : distanceToAddress // ignore: cast_nullable_to_non_nullable
              as double,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LocationCheckImpl implements _LocationCheck {
  const _$LocationCheckImpl(
      {required this.id,
      required this.verificationId,
      required this.checkTime,
      required this.latitude,
      required this.longitude,
      required this.accuracy,
      required this.isAtAddress,
      required this.distanceToAddress,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata;

  factory _$LocationCheckImpl.fromJson(Map<String, dynamic> json) =>
      _$$LocationCheckImplFromJson(json);

  @override
  final String id;
  @override
  final String verificationId;
  @override
  final DateTime checkTime;
  @override
  final double latitude;
  @override
  final double longitude;
  @override
  final double accuracy;
  @override
  final bool isAtAddress;
  @override
  final double distanceToAddress;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'LocationCheck(id: $id, verificationId: $verificationId, checkTime: $checkTime, latitude: $latitude, longitude: $longitude, accuracy: $accuracy, isAtAddress: $isAtAddress, distanceToAddress: $distanceToAddress, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LocationCheckImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.verificationId, verificationId) ||
                other.verificationId == verificationId) &&
            (identical(other.checkTime, checkTime) ||
                other.checkTime == checkTime) &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude) &&
            (identical(other.accuracy, accuracy) ||
                other.accuracy == accuracy) &&
            (identical(other.isAtAddress, isAtAddress) ||
                other.isAtAddress == isAtAddress) &&
            (identical(other.distanceToAddress, distanceToAddress) ||
                other.distanceToAddress == distanceToAddress) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      verificationId,
      checkTime,
      latitude,
      longitude,
      accuracy,
      isAtAddress,
      distanceToAddress,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LocationCheckImplCopyWith<_$LocationCheckImpl> get copyWith =>
      __$$LocationCheckImplCopyWithImpl<_$LocationCheckImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LocationCheckImplToJson(
      this,
    );
  }
}

abstract class _LocationCheck implements LocationCheck {
  const factory _LocationCheck(
      {required final String id,
      required final String verificationId,
      required final DateTime checkTime,
      required final double latitude,
      required final double longitude,
      required final double accuracy,
      required final bool isAtAddress,
      required final double distanceToAddress,
      final Map<String, dynamic>? metadata}) = _$LocationCheckImpl;

  factory _LocationCheck.fromJson(Map<String, dynamic> json) =
      _$LocationCheckImpl.fromJson;

  @override
  String get id;
  @override
  String get verificationId;
  @override
  DateTime get checkTime;
  @override
  double get latitude;
  @override
  double get longitude;
  @override
  double get accuracy;
  @override
  bool get isAtAddress;
  @override
  double get distanceToAddress;
  @override
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$LocationCheckImplCopyWith<_$LocationCheckImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LocationTrackingSummary _$LocationTrackingSummaryFromJson(
    Map<String, dynamic> json) {
  return _LocationTrackingSummary.fromJson(json);
}

/// @nodoc
mixin _$LocationTrackingSummary {
  String get verificationId => throw _privateConstructorUsedError;
  DateTime get trackingStarted => throw _privateConstructorUsedError;
  DateTime get trackingEnded => throw _privateConstructorUsedError;
  int get totalNights => throw _privateConstructorUsedError;
  int get successfulNights => throw _privateConstructorUsedError;
  int get requiredNights => throw _privateConstructorUsedError;
  bool get thresholdMet => throw _privateConstructorUsedError;
  List<LocationCheck> get checks => throw _privateConstructorUsedError;
  Map<String, dynamic> get statistics => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LocationTrackingSummaryCopyWith<LocationTrackingSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationTrackingSummaryCopyWith<$Res> {
  factory $LocationTrackingSummaryCopyWith(LocationTrackingSummary value,
          $Res Function(LocationTrackingSummary) then) =
      _$LocationTrackingSummaryCopyWithImpl<$Res, LocationTrackingSummary>;
  @useResult
  $Res call(
      {String verificationId,
      DateTime trackingStarted,
      DateTime trackingEnded,
      int totalNights,
      int successfulNights,
      int requiredNights,
      bool thresholdMet,
      List<LocationCheck> checks,
      Map<String, dynamic> statistics});
}

/// @nodoc
class _$LocationTrackingSummaryCopyWithImpl<$Res,
        $Val extends LocationTrackingSummary>
    implements $LocationTrackingSummaryCopyWith<$Res> {
  _$LocationTrackingSummaryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? verificationId = null,
    Object? trackingStarted = null,
    Object? trackingEnded = null,
    Object? totalNights = null,
    Object? successfulNights = null,
    Object? requiredNights = null,
    Object? thresholdMet = null,
    Object? checks = null,
    Object? statistics = null,
  }) {
    return _then(_value.copyWith(
      verificationId: null == verificationId
          ? _value.verificationId
          : verificationId // ignore: cast_nullable_to_non_nullable
              as String,
      trackingStarted: null == trackingStarted
          ? _value.trackingStarted
          : trackingStarted // ignore: cast_nullable_to_non_nullable
              as DateTime,
      trackingEnded: null == trackingEnded
          ? _value.trackingEnded
          : trackingEnded // ignore: cast_nullable_to_non_nullable
              as DateTime,
      totalNights: null == totalNights
          ? _value.totalNights
          : totalNights // ignore: cast_nullable_to_non_nullable
              as int,
      successfulNights: null == successfulNights
          ? _value.successfulNights
          : successfulNights // ignore: cast_nullable_to_non_nullable
              as int,
      requiredNights: null == requiredNights
          ? _value.requiredNights
          : requiredNights // ignore: cast_nullable_to_non_nullable
              as int,
      thresholdMet: null == thresholdMet
          ? _value.thresholdMet
          : thresholdMet // ignore: cast_nullable_to_non_nullable
              as bool,
      checks: null == checks
          ? _value.checks
          : checks // ignore: cast_nullable_to_non_nullable
              as List<LocationCheck>,
      statistics: null == statistics
          ? _value.statistics
          : statistics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LocationTrackingSummaryImplCopyWith<$Res>
    implements $LocationTrackingSummaryCopyWith<$Res> {
  factory _$$LocationTrackingSummaryImplCopyWith(
          _$LocationTrackingSummaryImpl value,
          $Res Function(_$LocationTrackingSummaryImpl) then) =
      __$$LocationTrackingSummaryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String verificationId,
      DateTime trackingStarted,
      DateTime trackingEnded,
      int totalNights,
      int successfulNights,
      int requiredNights,
      bool thresholdMet,
      List<LocationCheck> checks,
      Map<String, dynamic> statistics});
}

/// @nodoc
class __$$LocationTrackingSummaryImplCopyWithImpl<$Res>
    extends _$LocationTrackingSummaryCopyWithImpl<$Res,
        _$LocationTrackingSummaryImpl>
    implements _$$LocationTrackingSummaryImplCopyWith<$Res> {
  __$$LocationTrackingSummaryImplCopyWithImpl(
      _$LocationTrackingSummaryImpl _value,
      $Res Function(_$LocationTrackingSummaryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? verificationId = null,
    Object? trackingStarted = null,
    Object? trackingEnded = null,
    Object? totalNights = null,
    Object? successfulNights = null,
    Object? requiredNights = null,
    Object? thresholdMet = null,
    Object? checks = null,
    Object? statistics = null,
  }) {
    return _then(_$LocationTrackingSummaryImpl(
      verificationId: null == verificationId
          ? _value.verificationId
          : verificationId // ignore: cast_nullable_to_non_nullable
              as String,
      trackingStarted: null == trackingStarted
          ? _value.trackingStarted
          : trackingStarted // ignore: cast_nullable_to_non_nullable
              as DateTime,
      trackingEnded: null == trackingEnded
          ? _value.trackingEnded
          : trackingEnded // ignore: cast_nullable_to_non_nullable
              as DateTime,
      totalNights: null == totalNights
          ? _value.totalNights
          : totalNights // ignore: cast_nullable_to_non_nullable
              as int,
      successfulNights: null == successfulNights
          ? _value.successfulNights
          : successfulNights // ignore: cast_nullable_to_non_nullable
              as int,
      requiredNights: null == requiredNights
          ? _value.requiredNights
          : requiredNights // ignore: cast_nullable_to_non_nullable
              as int,
      thresholdMet: null == thresholdMet
          ? _value.thresholdMet
          : thresholdMet // ignore: cast_nullable_to_non_nullable
              as bool,
      checks: null == checks
          ? _value._checks
          : checks // ignore: cast_nullable_to_non_nullable
              as List<LocationCheck>,
      statistics: null == statistics
          ? _value._statistics
          : statistics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LocationTrackingSummaryImpl implements _LocationTrackingSummary {
  const _$LocationTrackingSummaryImpl(
      {required this.verificationId,
      required this.trackingStarted,
      required this.trackingEnded,
      required this.totalNights,
      required this.successfulNights,
      required this.requiredNights,
      required this.thresholdMet,
      required final List<LocationCheck> checks,
      required final Map<String, dynamic> statistics})
      : _checks = checks,
        _statistics = statistics;

  factory _$LocationTrackingSummaryImpl.fromJson(Map<String, dynamic> json) =>
      _$$LocationTrackingSummaryImplFromJson(json);

  @override
  final String verificationId;
  @override
  final DateTime trackingStarted;
  @override
  final DateTime trackingEnded;
  @override
  final int totalNights;
  @override
  final int successfulNights;
  @override
  final int requiredNights;
  @override
  final bool thresholdMet;
  final List<LocationCheck> _checks;
  @override
  List<LocationCheck> get checks {
    if (_checks is EqualUnmodifiableListView) return _checks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_checks);
  }

  final Map<String, dynamic> _statistics;
  @override
  Map<String, dynamic> get statistics {
    if (_statistics is EqualUnmodifiableMapView) return _statistics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_statistics);
  }

  @override
  String toString() {
    return 'LocationTrackingSummary(verificationId: $verificationId, trackingStarted: $trackingStarted, trackingEnded: $trackingEnded, totalNights: $totalNights, successfulNights: $successfulNights, requiredNights: $requiredNights, thresholdMet: $thresholdMet, checks: $checks, statistics: $statistics)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LocationTrackingSummaryImpl &&
            (identical(other.verificationId, verificationId) ||
                other.verificationId == verificationId) &&
            (identical(other.trackingStarted, trackingStarted) ||
                other.trackingStarted == trackingStarted) &&
            (identical(other.trackingEnded, trackingEnded) ||
                other.trackingEnded == trackingEnded) &&
            (identical(other.totalNights, totalNights) ||
                other.totalNights == totalNights) &&
            (identical(other.successfulNights, successfulNights) ||
                other.successfulNights == successfulNights) &&
            (identical(other.requiredNights, requiredNights) ||
                other.requiredNights == requiredNights) &&
            (identical(other.thresholdMet, thresholdMet) ||
                other.thresholdMet == thresholdMet) &&
            const DeepCollectionEquality().equals(other._checks, _checks) &&
            const DeepCollectionEquality()
                .equals(other._statistics, _statistics));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      verificationId,
      trackingStarted,
      trackingEnded,
      totalNights,
      successfulNights,
      requiredNights,
      thresholdMet,
      const DeepCollectionEquality().hash(_checks),
      const DeepCollectionEquality().hash(_statistics));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LocationTrackingSummaryImplCopyWith<_$LocationTrackingSummaryImpl>
      get copyWith => __$$LocationTrackingSummaryImplCopyWithImpl<
          _$LocationTrackingSummaryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LocationTrackingSummaryImplToJson(
      this,
    );
  }
}

abstract class _LocationTrackingSummary implements LocationTrackingSummary {
  const factory _LocationTrackingSummary(
          {required final String verificationId,
          required final DateTime trackingStarted,
          required final DateTime trackingEnded,
          required final int totalNights,
          required final int successfulNights,
          required final int requiredNights,
          required final bool thresholdMet,
          required final List<LocationCheck> checks,
          required final Map<String, dynamic> statistics}) =
      _$LocationTrackingSummaryImpl;

  factory _LocationTrackingSummary.fromJson(Map<String, dynamic> json) =
      _$LocationTrackingSummaryImpl.fromJson;

  @override
  String get verificationId;
  @override
  DateTime get trackingStarted;
  @override
  DateTime get trackingEnded;
  @override
  int get totalNights;
  @override
  int get successfulNights;
  @override
  int get requiredNights;
  @override
  bool get thresholdMet;
  @override
  List<LocationCheck> get checks;
  @override
  Map<String, dynamic> get statistics;
  @override
  @JsonKey(ignore: true)
  _$$LocationTrackingSummaryImplCopyWith<_$LocationTrackingSummaryImpl>
      get copyWith => throw _privateConstructorUsedError;
}
